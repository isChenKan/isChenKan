<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>重学《JavaScript高级程序设计》-核心语法 | 🤯社长の社畜</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="
数据类型
JavaScript原始数据类型(primitive)6个：Undefined, Null, Boolean, Number, String, Symbol。复杂数据类型1个：Object。

标识符
标识符是指变量、函数、属性的名字，或者函数的参数。
第一个字符必须是一个字母，下划线或一个美元符号。

typeof
typeof是一个操作符而不是函数。对于type ...">
    <link rel="preload" href="/assets/css/0.styles.fda92607.css" as="style"><link rel="preload" href="/assets/js/app.7f4b4882.js" as="script"><link rel="preload" href="/assets/js/8.4ab95c53.js" as="script"><link rel="preload" href="/assets/js/3.fadb76cf.js" as="script"><link rel="preload" href="/assets/js/7.dad84601.js" as="script"><link rel="prefetch" href="/assets/js/10.b2dc55ce.js"><link rel="prefetch" href="/assets/js/11.3a9e0bd4.js"><link rel="prefetch" href="/assets/js/12.7d472947.js"><link rel="prefetch" href="/assets/js/13.aa16d6c6.js"><link rel="prefetch" href="/assets/js/14.37208588.js"><link rel="prefetch" href="/assets/js/15.259fb6c8.js"><link rel="prefetch" href="/assets/js/16.6f1ef36b.js"><link rel="prefetch" href="/assets/js/17.5af21d96.js"><link rel="prefetch" href="/assets/js/18.6b7bd99c.js"><link rel="prefetch" href="/assets/js/19.c826f71e.js"><link rel="prefetch" href="/assets/js/20.d22504b7.js"><link rel="prefetch" href="/assets/js/21.55d5ab5c.js"><link rel="prefetch" href="/assets/js/22.a753f0b7.js"><link rel="prefetch" href="/assets/js/23.699657ef.js"><link rel="prefetch" href="/assets/js/24.b4c49572.js"><link rel="prefetch" href="/assets/js/25.3e4f7af1.js"><link rel="prefetch" href="/assets/js/26.1673bdbd.js"><link rel="prefetch" href="/assets/js/27.f2e3a149.js"><link rel="prefetch" href="/assets/js/28.683f14bc.js"><link rel="prefetch" href="/assets/js/29.e9f41ef1.js"><link rel="prefetch" href="/assets/js/30.1ad33a67.js"><link rel="prefetch" href="/assets/js/31.658218fc.js"><link rel="prefetch" href="/assets/js/32.2894414b.js"><link rel="prefetch" href="/assets/js/33.0ec3aa48.js"><link rel="prefetch" href="/assets/js/34.ed8c5abe.js"><link rel="prefetch" href="/assets/js/35.71e0d56d.js"><link rel="prefetch" href="/assets/js/36.66106bb5.js"><link rel="prefetch" href="/assets/js/4.3792b2f6.js"><link rel="prefetch" href="/assets/js/5.57997a9e.js"><link rel="prefetch" href="/assets/js/6.2f06e37f.js"><link rel="prefetch" href="/assets/js/9.929f25d0.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.9c3680bd.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fda92607.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">🤯社长の社畜 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">文章</a></li><li class="nav-item"><a href="/tag/" class="nav-link">标签</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">🤯社长の社畜 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">文章</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">标签</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">社长的社畜</span> <span itemprop="address">   in 北京</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-02-04T00:00:00.000Z">
      Tue Feb 04 2020
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/JavaScript" data-v-42ccfcd5><span data-v-42ccfcd5>JavaScript</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h1 id="重学《javascript高级程序设计》-核心语法"><a href="#重学《javascript高级程序设计》-核心语法" class="header-anchor">#</a> 重学《JavaScript高级程序设计》-核心语法</h1> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <p>JavaScript原始数据类型(primitive)6个：Undefined, Null, Boolean, Number, String, Symbol。复杂数据类型1个：Object。</p> <h2 id="标识符"><a href="#标识符" class="header-anchor">#</a> 标识符</h2> <p>标识符是指变量、函数、属性的名字，或者函数的参数。
第一个字符必须是一个字母，下划线或一个美元符号。</p> <h2 id="typeof"><a href="#typeof" class="header-anchor">#</a> typeof</h2> <p>typeof是一个操作符而不是函数。对于typeof()这种使用方式，括号不是必须的。</p> <p>对未初始化和未声明的变量执行typeof操作符都会返回&quot;undefined&quot;。因为未声明的变量的数据类型就是Undefined。用var等关键字声明了但未初始化值的变量，它的值是undefined，它的数据类型是Undefined。</p> <p>typeof检测null值返回会返回&quot;object&quot;。<strong>因为null值表示一个空对象指针</strong>，undefined值派生自null值。按照规定，undefined == null要返回true。引入undefined是为了正式区分空对象指针与未经初始化的变量。没有必要显式的将一个变量声明为undefined，但是只要意在保存对象的变量还没有真正保存对象，就应该明确的让该变量保存null值。</p> <p>undefined/null两者却在实现上完全不同：undefined是一个全局属性（在global上），而null是一个关键字。</p> <p>typeof函数会返回“function”，准确的说，函数不是一种数据类型，而是对象。因为函数比较特殊，所以typeof区分了函数和其他对象。</p> <p><img src="/assets/img/null.7ca3c05f.png" alt="image"></p> <h2 id="boolean"><a href="#boolean" class="header-anchor">#</a> Boolean()</h2> <p>Boolean()会把任何类型的值转换成Boolean类型。与!!效果相同。
对于String：任何非空字符串（注意：''是空字符串，而'   '里面有空格，是非空字符串）会返回true，只有空字符串返回false；
对于Number：任何非零数字值（包括无穷大）返回true，0和NaN返回false；
对于Object：任何对象返回true（Boolean({}) // true），只有null返回false。
if语句会自动根据以上规则执行Boolean转换。</p> <h2 id="浮点数运算"><a href="#浮点数运算" class="header-anchor">#</a> 浮点数运算</h2> <p>由于保存浮点数需要的内存空间是保存整数的两倍，因此JS会不失时机地将浮点数转换为整数值。如果浮点数表示的值本身就是一个整数，比如10.0，那么会被转换成整数10。</p> <p>浮点数的最高精度是17位小数，0.1 + 0.2不等于0.3的问题。因为计算机是转换成二进制来运算的（计算方法是：对于整数，除2取余；对于小数，乘2取整），0.1和0.2在有限的精度内转换成二进制都是不精确的（无限循环），所以在有限的精度内二进制只能取近似值，进而无法得到准确的0.3，但是0.05和0.25就可以准确的用二进制表示，可以得到0.3。但是无法精确表示的0.1+0.4却可以得到可以用二进制准确表示的0.5，这是因为在有限精度的二进制世界里，与0.1+0.4得到的那个无限位的二进制数最接近的二进制数，转换成十进制数刚好就是0.5。</p> <p>详细原理请看：《IEEE 754》</p> <h2 id="nan"><a href="#nan" class="header-anchor">#</a> NaN</h2> <p>任何数值除以非数值会返回NaN，NaN与任何值都不相等，包括NaN本身。isNaN()尝试将接收到值转换为数值，不能转换为数值，返回false。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">// flase</span>
<span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// flase</span>
</code></pre></div><p>isNaN函数其实等同于回答了这样一个问题：被测试的值在被强制转换成数值时会不会返回IEEE-754 中所谓的“不是数值（not a number）”。
和全局函数 isNaN() 相比，Number.isNaN() 不会自行将参数转换成数字，只有在参数是值为 NaN 的数字时，才会返回 true。</p> <h2 id="number-parseint-parsefloat"><a href="#number-parseint-parsefloat" class="header-anchor">#</a> Number(), parseInt(), parseFloat()</h2> <p>数值转换函数：Number(), parseInt(), parseFloat()</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 123</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">&quot;123a&quot;</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>

<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>只会解析数字字符，直到遇到一个非数字字符为止。
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;123a&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 123</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;22.5&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 22（因为小数点不是有效的数字字符）</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>第二个参数是几进制的基数，<span class="token number">2</span>、<span class="token number">8</span>、<span class="token number">10</span>、<span class="token number">16</span>。

<span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>可以识别第一个小数点。
<span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;22.5&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 22.5</span>
</code></pre></div><h2 id="string"><a href="#string" class="header-anchor">#</a> String</h2> <p>JavaScript中的字符串是不可变的，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p> <h2 id=""><a href="#" class="header-anchor">#</a> +</h2> <p>只有null和undefined没有toString方法，但是可以用String()方法返回任何数据类型的值转换为字符串，即调用他们的toString方法，而这两个值直接返回&quot;null&quot;和&quot;undefined&quot;。要把某个值转换为字符串，可以使用+号把它和一个字符串&quot;&quot;加在一起。</p> <p>一元加和减运算符除了用于基本的算数运算，还可以用来转换数据类型，跟Number()效果一样。</p> <p>JS中的所有数值都是64位格式存储，但是会转换成32位整数操作。第32位是符号位，0为正，1为负。</p> <h2 id="～-｜"><a href="#～-｜" class="header-anchor">#</a> ～ &amp; ｜ ^</h2> <p>按位非~，执行按位非的结果是返回数值的反码（32位二进制数，每一位反过来）。非操作的本质，操作数的负值减1。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">25</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token operator">~</span>a <span class="token comment">// -26</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token operator">-</span>a <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">// -26 虽然结果一样，但是按非操作直接操作底层，速度更快。</span>
</code></pre></div><ul><li>按位与&amp;，对应位置都是1才返回1。</li> <li>按位或|，对应位置有一个1就返回1。</li> <li>按位异或^，对应位置只有一个1才返回1。</li></ul> <h2 id="-2"><a href="#-2" class="header-anchor">#</a> &amp;&amp;</h2> <p>&amp;&amp;逻辑与（&amp;&amp;）操作是短路操作，第一个操作数转换成布尔值如果是false，那么返回第一个。如果第一个操作数是true，则返回第二个操作数。
解释一下第二句话，如果&amp;&amp;两边都是布尔值，那么第一个为true，最终的结果取决于第二个。同理，如果第一个操作数是对象（其实相当于第一个是true），则返回第二个操作数。eg：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span>b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span> <span class="token comment">// {b: 2} 第一个操作数是true，返回第二个。</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token comment">// 2 第一个操作数是true，返回第二个。</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token comment">// false 第一个操作数是false，返回第一个。</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">''</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token comment">// '' 第一个''是空字符串，是false，返回第一个。</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'  '</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token comment">// 2 第一个'  '有空格的字符串，属于非空字符串，是true，所以返回第二个。</span>
</code></pre></div><h2 id="-3"><a href="#-3" class="header-anchor">#</a> ||</h2> <p>逻辑或（||）也是短路操作，跟上文类似，||是第一个操作数转换成布尔值如果是true，那么返回第一个。如果第一个操作数是false，则返回第二个。</p> <h2 id="算数运算符"><a href="#算数运算符" class="header-anchor">#</a> 算数运算符</h2> <p>加法运算：如果一个是字符串，则将另一个转换成字符串，拼接起来，常犯的错误：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">'the sum of 1 and 2 is '</span> <span class="token operator">+</span> a <span class="token operator">+</span> b <span class="token comment">// c: 'the sum of 1 and 2 is 12'</span>
</code></pre></div><p>如果第一个不是字符串，加法运算则不会拼接字符串，对第二个运行Number()转换成数字，如果结果是NaN，那么最终的结果也就是NaN。</p> <h2 id="大于小于比较"><a href="#大于小于比较" class="header-anchor">#</a> 大于小于比较</h2> <p>如果一个是数字，另一个是字符串，则先将其转换成数值再比较，如果无法转换成数值，即转换结果是NaN，则返回false，根据约定，任何数跟NaN用&lt; &gt;比较大小结果都是false。</p> <h2 id="if语句"><a href="#if语句" class="header-anchor">#</a> if语句</h2> <p>if (condition) {}，其中condition表达式的结果不一定是布尔值，但是会自动调用Boolean()。</p> <h2 id="with"><a href="#with" class="header-anchor">#</a> with</h2> <p>with可能带来性能问题，少用。它的作用主要是简化多次编写同一个对象的工作，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> obj<span class="token punctuation">.</span>a
<span class="token keyword">var</span> b <span class="token operator">=</span> obj<span class="token punctuation">.</span>b
<span class="token keyword">var</span> c <span class="token operator">=</span> obj<span class="token punctuation">.</span>c
<span class="token comment">// with</span>
<span class="token keyword">with</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> a
	<span class="token keyword">var</span> b <span class="token operator">=</span> b
	<span class="token keyword">var</span> c <span class="token operator">=</span> c
<span class="token punctuation">}</span>
</code></pre></div><h2 id="arguments"><a href="#arguments" class="header-anchor">#</a> arguments</h2> <p>JS函数的一个重要特点：命名的参数只提供便利，但不是必需的。参数名字只是提供便利而已，完全可以用arguments。</p> <p>所以参数传递的都是值，不可能通过引用传递参数。</p> <p>未指定返回值的函数返回undefined。</p> <h2 id="按值传递"><a href="#按值传递" class="header-anchor">#</a> 按值传递</h2> <p>JS中所以函数的参数都是按值传递的。被传递的值会被赋值给一个局部变量（即命名参数，换句话说，就是arguments对象中的一个元素）。按值传递说明里面的局部变量被赋值为传入值，互不影响。但是在向参数传递引用类型的值时，对它的操作会影响到外部。但是它也是按值传递的，只不过传递的是一个引用，即使在函数内部修改了参数的值，但原始的引用并不会改变。但会引起此副作用。</p> <h2 id="instantsof"><a href="#instantsof" class="header-anchor">#</a> instantsof</h2> <p>所有引用类型的值都是Object的实例。检测是何种类型的对象：instanceof。</p> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <p>函数是对象，函数名实际上是一个指向函数对象的指针。这也是没有重载的原因，第二个同名函数会覆盖第一个，这其实相当于把一个变量重新赋值。</p> <p>函数声明和函数表达式的区别是，函数声明会被解析器率先解析，而函数表达式必须等到解析器执行到它，才会真正被解释执行。</p> <p>函数是对象，所以函数也有属性和方法，每个函数都包含两个属性：length和prototype。length表示函数希望接收的命名参数的个数。对于JS中的引用类型，prototype是保存它们所有实例方法的真正所在。</p> <h2 id="this"><a href="#this" class="header-anchor">#</a> this</h2> <p>this引用的是函数执行的环境对象。</p> <h2 id="基本包装类型"><a href="#基本包装类型" class="header-anchor">#</a> 基本包装类型</h2> <p>JS提供了3个特殊的引用类型：Boolean, String, Number。这三个对应的基本类型不是对象，从逻辑上应该没有方法，但是却有substring()等方法。原因是在创建基本类型的值的时候，后台会创建一个对应的基本包装类型的对象，从而实现了一些方法。创建过程：</p> <ol><li>创建String类型的一个实例。</li> <li>在实例上调用指定的方法。</li> <li>销毁这个实例。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token string">'some text'</span>
<span class="token keyword">var</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">// 相当于：</span>
<span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'some text'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
s1 <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// 所以我们可以理解这段代码了：var s1 = 'some text'</span>
s1<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span> <span class="token comment">// 临时创建了一个String包装对象s1，给这个对象增加了一个color属性，这行代码执行完之后，就被销毁了</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token comment">// undefined，然而，这里读取s1的color属性时，又创建了一个String包装对象，但是它没有color属性</span>
</code></pre></div><p>Object构造函数会根据传入值的类型创建相应的基本包装类型的实例：
var obj = new Object('some text')
obj instanceof String // true</p> <h2 id="进制转换方法"><a href="#进制转换方法" class="header-anchor">#</a> 进制转换方法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">10</span>
num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 转换成二进制&quot;1010&quot;</span>
num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token comment">// 转换成十六进制&quot;a&quot;</span>
</code></pre></div><h2 id="object-defineproperty"><a href="#object-defineproperty" class="header-anchor">#</a> Object.defineProperty()</h2> <p>对象有两种属性：</p> <ul><li>数据属性：四个特性，（[[Configurable]], [[Enumerable]], [[Writeable]], [[Value]]），对象值实际存储的位置就是[[Value]]。</li> <li>访问器属性：四个特性，（[[Configurable]], [[Enumerable]], [[Get]], [[Set]]）
Object.getOwnPropertyDescriptor(obj, 'name')获取属性描述符。</li></ul> <p><img src="/assets/img/define.410bb92d.png" alt="image"></p> <h2 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h2> <p>工厂模式的问题是无法识别对象的具体类型。</p> <h2 id="构造函数模式（new操作发生了什么？）"><a href="#构造函数模式（new操作发生了什么？）" class="header-anchor">#</a> 构造函数模式（new操作发生了什么？）</h2> <p>构造函数模式的问题是每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数是不相等的。</p> <h2 id="object-keys"><a href="#object-keys" class="header-anchor">#</a> Object.keys()</h2> <p>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</p> <h2 id="new"><a href="#new" class="header-anchor">#</a> new</h2> <p><img src="/assets/img/new.9960f62e.png" alt="image"></p> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <p>原型继承：令一个对象(a)的原型等于另一个对象(b)的实例（a.prototype = new b();），这样这个对象(a)的原型就成为了另一个对象(b)的实例，而实例里包含了指向其原型对象(b.prototype)的指针，那么，这个对象(a)就拥有了指向另一个对象(b)的指针。这就是原型链（继承），此时，当访问a中没有的属性或方法时，便会顺着原型链找到父对象(b)里的属性或方法。</p> <p>所以的引用类型默认都继承了Object，它们都会包含一个内部指针，指向Object.prototype。</p> <p>原型链继承的两个问题：</p> <p>同原型模式存在的问题一样，对于引用类型，包含引用类型值的原型属性会被所有实例共享，而这也是为什么要在构造函数中，而不是在原型中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性就变成了现在的原型属性了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// B继承了A，B.prototype成了构造函数A的一个实例，因此B.prototype拥有了一个它自己的nums属性--就跟专门创建了一个B.prototype.nums属性一样，它是构造函数B的实例共享的。</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
b1<span class="token punctuation">.</span>nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>nums<span class="token punctuation">)</span> <span class="token comment">// 1,2,3,4</span>

<span class="token keyword">var</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b2<span class="token punctuation">.</span>nums<span class="token punctuation">)</span> <span class="token comment">// 1,2,3,4</span>
</code></pre></div><p>原型链的第二个问题，在创建子类型的实例时，不能向超类型的构造函数（不影响所有实例的情况下）中传递参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 借用构造函数实现继承：</span>
<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 通过call实际上在（未来将要）新建的B的实例的环境下调用了构造函数A，所以new B()的时候实际也执行了A的代码来为新的实例创建属性。	A.call(this, 'example')</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">24</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> b1<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 'example' 24</span>
</code></pre></div><p>构造函数继承也存在构造函数模式的问题，函数无法复用，且在超类型的原型中定义的方法对于子类型是不可见的。
也就是说原型链里并不会找到A，找say()方法的过程应该是：<code>b1 =&gt; B.prototype =&gt; Object.prototype</code> <img src="/assets/img/jicheng.5d33b73f.png" alt="image"></p> <p>记住这张图中的prototype, constructor, <strong>proto</strong>(即[[prototype]])的关系：实例跟构造函数没有直接的联系。
<img src="/assets/img/proto.11163acf.png" alt="image"></p> <h2 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h2> <p>用构造函数继承实例属性（也就是说这个属性是实例自己的，每个实例创建一个），用原型链继承原型属性和方法（它俩是实例共享的）。组合继承的问题：会调用两次超类型的构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
	<span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// 继承实例属性，并且传递参数，第二次调用A()，在新对象上创建了两个实例属性(name, nums)，屏蔽了原型中(B.prototype)的两个同名属性，它们不是共享的。</span>
	<span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">}</span>

<span class="token comment">// 继承方法，第一次调用A()，B的原型中(B.prototype)得到了两个属性(name, nums)，而且它们是共享的。</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 重写原型会失去constructor，这里重新设置为构造函数B</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">B</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
b1<span class="token punctuation">.</span>nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>nums<span class="token punctuation">)</span> <span class="token comment">// 1,2,3,4</span>
b1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
b1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'b1'</span>

<span class="token keyword">var</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>nums<span class="token punctuation">)</span> <span class="token comment">// 1,2,3</span>
b1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
b1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'b2'</span>
</code></pre></div><h2 id="原型式继承"><a href="#原型式继承" class="header-anchor">#</a> 原型式继承</h2> <p>Object.create()由此演变而来，可以以一个对象为原型来创建一个新对象。本质上也是利用prototype实现继承。核心代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
<span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>对传入其中的对象执行了一次浅拷贝。
</code></pre></div></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#数据类型" title="数据类型">数据类型</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#标识符" title="标识符">标识符</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#typeof" title="typeof">typeof</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#boolean" title="Boolean()">Boolean()</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#浮点数运算" title="浮点数运算">浮点数运算</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#nan" title="NaN">NaN</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#number-parseint-parsefloat" title="Number(), parseInt(), parseFloat()">Number(), parseInt(), parseFloat()</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#string" title="String">String</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#" title="+">+</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#～-｜" title="～ &amp; ｜ ^">～ &amp; ｜ ^</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#-2" title="&amp;&amp;">&amp;&amp;</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#-3" title="||">||</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#算数运算符" title="算数运算符">算数运算符</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#大于小于比较" title="大于小于比较">大于小于比较</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#if语句" title="if语句">if语句</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#with" title="with">with</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#arguments" title="arguments">arguments</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#按值传递" title="按值传递">按值传递</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#instantsof" title="instantsof">instantsof</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#函数" title="函数">函数</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#this" title="this">this</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#基本包装类型" title="基本包装类型">基本包装类型</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#进制转换方法" title="进制转换方法">进制转换方法</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#object-defineproperty" title="Object.defineProperty()">Object.defineProperty()</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#工厂模式" title="工厂模式">工厂模式</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#构造函数模式（new操作发生了什么？）" title="构造函数模式（new操作发生了什么？）">构造函数模式（new操作发生了什么？）</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#object-keys" title="Object.keys()">Object.keys()</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#new" title="new">new</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#继承" title="继承">继承</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#组合继承" title="组合继承">组合继承</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#原型式继承" title="原型式继承">原型式继承</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940><li class="contact-item" data-v-fdbf4940><a href="mailto: ischenkan@outlook.com" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-fdbf4940><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-fdbf4940></path><polyline points="22,6 12,13 2,6" data-v-fdbf4940></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940><li class="copyright-item" data-v-fdbf4940><a href="https://kuifafa.com" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940>Create by 🐱社长的社畜</a></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7f4b4882.js" defer></script><script src="/assets/js/8.4ab95c53.js" defer></script><script src="/assets/js/3.fadb76cf.js" defer></script><script src="/assets/js/7.dad84601.js" defer></script>
  </body>
</html>
