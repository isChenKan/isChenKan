(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{492:function(t,a,s){"use strict";s.r(a);var n=s(8),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"js基础之：callback和promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js基础之：callback和promise"}},[t._v("#")]),t._v(" JS基础之：callback和promise")]),t._v(" "),s("blockquote",[s("p",[t._v("这里我不会过多的讨论它们具体的写法、API层面的东西，promise想必大家都会用，这里主要讨论的是API背后的原理。")])]),t._v(" "),s("h2",{attrs:{id:"callback为什么不好"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#callback为什么不好"}},[t._v("#")]),t._v(" callback为什么不好")]),t._v(" "),s("p",[t._v("我们的大脑其实是单线程在工作的，当然，我是说除了呼吸，心跳这些维持生命迹象的行为外。我们感觉自己在多线程的做一些事情的时候，其实我们是在进行快速的上下文切换而已。快到有一种我们的大脑在同时处理多件事情一样。我们其实不能一心多用。举个例子：我们很难真正做到一遍打字一边打电话，当我们以为自己在同时做这两件事情的时候，其实是迅速的在这两件事情之间切换。我们的大脑其实是同步的，有点像是顺序执行任务的。所以通过回调写出来的异步代码，跟我们的大脑的处理逻辑是相悖的，这很不自然。")]),t._v(" "),s("h3",{attrs:{id:"回调地狱"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回调地狱"}},[t._v("#")]),t._v(" 回调地狱")]),t._v(" "),s("p",[t._v("先看一段假设的代码：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doA")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doC")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doD")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这段代码的实际的执行顺序应该是："),s("code",[t._v("AFBCED")]),t._v("，但是，如果函数A和C不是异步的呢？")]),t._v(" "),s("p",[s("strong",[t._v("回调地狱的问题不是嵌套和缩进")]),t._v("，你也可以把它写成线性的。问题在于它的同步异步是无法控制的，回调函数表达异步的方式让我们很难追踪代码的逻辑。")]),t._v(" "),s("h3",{attrs:{id:"回调函数信任问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回调函数信任问题"}},[t._v("#")]),t._v(" 回调函数信任问题")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// A")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$ajax")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/some/api'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("res")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// C ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// B")]),t._v("\n")])])]),s("p",[t._v("上面的代码执行顺序应该是："),s("code",[t._v("ABC")]),t._v("，我们使用了一个第三方的ajax库，这里就存在控制反转，把程序的控制权给了第三方，存在严重的信任问题。第三方如果不执行回调函数怎么办？多次执行回调函数怎么办？执行回调过早或过晚？（不能确定是现在还是将来调用你的回调）我们需要在我们的代码中加入很多容错代码来处理这样的事情，这很累。")]),t._v(" "),s("p",[t._v("我们需要一种更同步、更顺序的方式来表达异步的代码。这就是"),s("code",[t._v("promise")]),t._v("!")]),t._v(" "),s("h2",{attrs:{id:"promise：承诺未来值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise：承诺未来值"}},[t._v("#")]),t._v(" promise：承诺未来值")]),t._v(" "),s("p",[t._v("promise就像餐厅取餐叫号一样，你的这个号就是给你的承诺，一个未来值，一段时间后，你可以拿这个号去换取你的食物。或者餐厅告诉你，卖完了，换不了，这就是promise，要么完成，要么拒绝。")]),t._v(" "),s("p",[t._v("由于Promise封装了依赖于时间的状态——等待底层值的完成或拒绝，所以Promise本身是与时间无关的。因此，Promise可以按照可预测的方式组成(组合，使用.then)，而不用关心时序或底层的结果。一旦Promise决议，它就永远保持在这个状态。")]),t._v(" "),s("h3",{attrs:{id:"promise如何解决callback的信任问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise如何解决callback的信任问题"}},[t._v("#")]),t._v(" promise如何解决callback的信任问题")]),t._v(" "),s("p",[t._v("callback把控制权交给第三方导致了信任问题，第三方代码可能过早或过晚的调用我们传给它的回调函数，而promise就不用担心这个问题，promise总是异步的。而且promise的回调调用次数是一次，不会出现多次调用回调函数的情况。")]),t._v(" "),s("p",[t._v("之前我们使用callback，我们把回调函数传给了"),s("code",[t._v("$ajax")]),t._v("，是不值得信任的。而"),s("strong",[t._v("promise决议之后只负责通知（成功或拒绝），现在我们把回调传给promise的then来精确控制。")])]),t._v(" "),s("h3",{attrs:{id:"异常捕获"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常捕获"}},[t._v("#")]),t._v(" 异常捕获")]),t._v(" "),s("p",[t._v("另外，promise可以用catch来捕获异常，callback虽然可以用try catch来捕获异常，但是无法捕捉到异步的异常，所以相比来说，promise的机制更好。")]),t._v(" "),s("p",[t._v("记住："),s("strong",[t._v("promise只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次")]),t._v("。")])])}),[],!1,null,null,null);a.default=r.exports}}]);