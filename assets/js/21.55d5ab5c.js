(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{504:function(t,s,a){"use strict";a.r(s);var n=a(8),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"js基础之：什么是闭包？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js基础之：什么是闭包？"}},[t._v("#")]),t._v(" JS基础之：什么是闭包？")]),t._v(" "),a("h2",{attrs:{id:"什么是闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[t._v("#")]),t._v(" 什么是闭包")]),t._v(" "),a("p",[t._v("闭包就是"),a("strong",[t._v("能够读取其他函数内部变量的函数")]),t._v("。或者说当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，就会形成闭包。所以闭包的"),a("strong",[t._v("本质是基于词法作用域和将函数按值传递")]),t._v("（因为js中函数是第一公民，函数可以被当作值传递）。")]),t._v(" "),a("p",[t._v("闭包的特点：")]),t._v(" "),a("ul",[a("li",[t._v("闭包基于词法作用域的查找规则")]),t._v(" "),a("li",[t._v("在一个函数内定义一个函数，并将这个函数作为值返回，或者直接或间接的执行这个函数")]),t._v(" "),a("li",[t._v("拥有更长的生命周期，保持了对当前词法作用域的引用，使得从外部通过这个函数能访问到内部的变量，自由使用。闭包不会被内存吃掉，但是有可能引起内存泄漏。")])]),t._v(" "),a("p",[t._v("先看一个例子：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" kuihua "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'🌻'")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" kuihua\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" bar\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里foo执行之后作用域就被销毁了")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是因为闭包的存在，下面的baz()还是能访问到kuihua这个变量")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" baz "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("baz")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// '🌻'")]),t._v("\n")])])]),a("h2",{attrs:{id:"闭包的使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的使用场景"}},[t._v("#")]),t._v(" 闭包的使用场景")]),t._v(" "),a("p",[t._v("闭包通常用来创建内部变量，使得这些变量不能被外部随意修改（私有性），同时又可以通过指定的函数接口来操作。感觉在一些类库的底层设计上会接触的比较多一点。")])])}),[],!1,null,null,null);s.default=r.exports}}]);