(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{445:function(t,e,v){t.exports=v.p+"assets/img/eventloop.86a40bb3.png"},508:function(t,e,v){"use strict";v.r(e);var _=v(8),s=Object(_.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"node的异步i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node的异步i-o"}},[t._v("#")]),t._v(" Node的异步I/O")]),t._v(" "),_("h2",{attrs:{id:"node本身是多线程的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node本身是多线程的"}},[t._v("#")]),t._v(" Node本身是多线程的")]),t._v(" "),_("p",[t._v("Node的异步I/O实际上也是利用线程池实现的。我们经常说Node是单线程的，但是实际上只是说最上层的JavaScript是在单线程中执行的。Node底层还是通过线程池来实现异步I/O的。只有js是单线程的，Node本身是多线程的。异步实现：Windows: IOCP, *nix: 多线程。Node通过libuv封装了这两种实现。")]),t._v(" "),_("h2",{attrs:{id:"node自上而下的结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node自上而下的结构"}},[t._v("#")]),t._v(" Node自上而下的结构")]),t._v(" "),_("p",[t._v("JavaScript（运行在V8上，V8集成到了Node里面）↓")]),t._v(" "),_("p",[t._v("Nodejs核心模块↓")]),t._v(" "),_("p",[t._v("C++内建模块↓")]),t._v(" "),_("p",[t._v("libuv系统调用（中间层，平台判断，兼容处理Windows和*nix平台）。")]),t._v(" "),_("h2",{attrs:{id:"请求对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#请求对象"}},[t._v("#")]),t._v(" 请求对象")]),t._v(" "),_("p",[t._v("从JavaScript层面发起的异步调用开始，会创建一个"),_("strong",[t._v("请求对象")]),t._v("，它保存了所有的请求状态，参数，回调。请求对象会被推入线程池等待执行。Node异步调用过程：")]),t._v(" "),_("p",[t._v("JavaScript ↓")]),t._v(" "),_("p",[t._v("调用Node核心模块 ↓")]),t._v(" "),_("p",[t._v("调用C++模块 ↓")]),t._v(" "),_("p",[t._v("libuv封装一个请求对象 ↓")]),t._v(" "),_("p",[t._v("不同的平台调用不同的系统API ↓")]),t._v(" "),_("p",[t._v("送入线程池等待执行 ↓")]),t._v(" "),_("p",[t._v("js立即返回并继续执行。")]),t._v(" "),_("h2",{attrs:{id:"线程池"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[t._v("#")]),t._v(" 线程池")]),t._v(" "),_("p",[t._v("线程可用 ↓")]),t._v(" "),_("p",[t._v("执行请求对象的I/O操作 ↓")]),t._v(" "),_("p",[t._v("执行完成后将结果放入请求对象中 ↓")]),t._v(" "),_("p",[t._v("通知系统调用完成了（观察者通过调用系统内核的方法来检查线程池中是否有执行完的请求）。")]),t._v(" "),_("h2",{attrs:{id:"node事件循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node事件循环"}},[t._v("#")]),t._v(" Node事件循环")]),t._v(" "),_("p",[t._v("在进程启动时，Node会创建一个类似于"),_("code",[t._v("while(true)")]),t._v("的循环，每执行一次循环就是一个"),_("code",[t._v("Tick")]),t._v("。每个Tick就是查看有没有事件待处理（通过观察者来查看，观察者可以有很多个：文件I/O观察者，网络I/O观察者，事件循环去观察者里面取出事件），如果有就从观察者那里取出请求对象，取出回调函数执行。然后进入下一个Tick，最后没有事件了，就退出进程。概括来说就是：")]),t._v(" "),_("p",[t._v("创建主循环 ↓")]),t._v(" "),_("p",[t._v("每个Tick从观察者里取请求对象（观察者通过调用系统内核方法来检查线程池中是否有执行完的请求）↓")]),t._v(" "),_("p",[t._v("取出回调函数执行 ↓")]),t._v(" "),_("p",[t._v("下一个Tick。")]),t._v(" "),_("h4",{attrs:{id:"settimeout-、progress-nexttick-、setimmediate"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-、progress-nexttick-、setimmediate"}},[t._v("#")]),t._v(" setTimeout()、progress.nextTick()、setImmediate()")]),t._v(" "),_("p",[_("code",[t._v("setTimeout()")]),t._v("的原理差不多，只是不需要I/O线程池的参与。调用setTimeout()创建的定时器会被插入到"),_("strong",[t._v("定时器观察者")]),t._v("内部的一个红黑树中，每次Tick执行的时候，会从该红黑树中迭代取出定时器对象，检查是否查过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。")]),t._v(" "),_("p",[_("code",[t._v("progress.nextTick()")]),t._v(": 效果和setTimeout(fn, 0)差不多，但是性能更好一点。并且优先级高于"),_("code",[t._v("setImmediate()")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"顺便看看浏览器中的事件循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#顺便看看浏览器中的事件循环"}},[t._v("#")]),t._v(" 顺便看看浏览器中的事件循环")]),t._v(" "),_("ul",[_("li",[t._v("所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。")]),t._v(" "),_("li",[t._v('主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过'),_("strong",[t._v("回调函数")]),t._v('，这些事件发生时就会进入"任务队列"，等待主线程读取。')]),t._v(" "),_("li",[t._v('一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（"任务队列"上第一位的事件就自动进入主线程，对于setTimeout，主线程首先要检查一下执行时间，只有到了规定的时间，才能返回主线程。）')]),t._v(" "),_("li",[t._v("主线程不断重复上面的第三步。")])]),t._v(" "),_("h4",{attrs:{id:"settimeout-fn-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-fn-0"}},[t._v("#")]),t._v(" setTimeout(fn, 0)")]),t._v(" "),_("p",[t._v('setTimeout(fn, 0)的含义是：指定某个任务在主线程最早的空闲时间执行，也就是说，尽可能早的执行。它在"任务队列"的'),_("strong",[t._v("尾部")]),t._v("添加一个事件，"),_("strong",[t._v('因此要等到同步任务和"任务队列"现有的事件都处理完')]),t._v("，才会得到执行。为了证实黑体字这句话，我写了一个例子：\n"),_("img",{attrs:{src:v(445),alt:"eventloop"}}),t._v("\n由此可见：")]),t._v(" "),_("ul",[_("li",[t._v("setTimeout是有顺序的，setTimeout(fn, 0)并不会插队。例子中的第一个setTimeout排在第二个setTimeout前面。至于谁先执行就不一定了。")]),t._v(" "),_("li",[t._v("主线程会检查setTimeout的时间（这个时间是从执行到setTimeout这一行，setTimeout的回调被放入任务队列中开始计时的），如果没到时间，就算在任务队列的最前面，也不会执行。就像图中的第二种情况。")])]),t._v(" "),_("h4",{attrs:{id:"任务队列分为宏任务队列和微任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#任务队列分为宏任务队列和微任务"}},[t._v("#")]),t._v(" 任务队列分为宏任务队列和微任务")]),t._v(" "),_("ul",[_("li",[t._v("宏任务："),_("code",[t._v("setTimeout()")]),t._v(", "),_("code",[t._v("setInterval()")])]),t._v(" "),_("li",[t._v("微任务："),_("code",[t._v("new Promise()")])])]),t._v(" "),_("p",[t._v("当执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，"),_("strong",[t._v("微任务先执行，优先级更高")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"node的事件驱动服务模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node的事件驱动服务模型"}},[t._v("#")]),t._v(" Node的事件驱动服务模型")]),t._v(" "),_("p",[t._v("Apache采用的是多线程/多进程的模型实现的，而Nginx和Node是采用"),_("strong",[t._v("事件驱动")]),t._v("的方式实现的。属于单线程模型，即不用为每一个请求创建一个线程，多线程就是让一个线程服务一个请求，高并发的时候内存就很吃力了，多线程还有创建线程和执行期线程上下文切换的开销较大，锁，状态同步等问题。Node的事件驱动的方式，采用单线程避免了不必要的内存开销和操作系统上下文切换开销。")]),t._v(" "),_("p",[t._v("但是，事件驱动的服务模型两个缺点：")]),t._v(" "),_("ul",[_("li",[t._v("CPU的利用率（单进程单线程模型只能利用一个核）")]),t._v(" "),_("li",[t._v("进程的健壮性和稳定性（单线程出了问题引起整个应用崩溃）")])]),t._v(" "),_("h2",{attrs:{id:"cpu利用率问题（child-progress）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cpu利用率问题（child-progress）"}},[t._v("#")]),t._v(" CPU利用率问题（child_progress）")]),t._v(" "),_("p",[t._v("利用"),_("code",[t._v("child_progress.fork()")]),t._v("创建子进程（工作进程），从而利用多核CPU。每个fork的工作进程都有自己的V8实例（但是fork()的代价比较昂贵）。这就是Master-Worker主从模式，主进程负责管理和调度。Node主进程和工作进程之间的通信通过创建"),_("strong",[t._v("IPC通道")]),t._v("（主先创建IPC通道，然后告诉子这个IPC通道的文件描述符，子据此去连接这个已经存在的IPC通道），然后主、子进程之间的通信通过"),_("code",[t._v("message")]),t._v("事件和"),_("code",[t._v("send()")]),t._v("方法来完成，通过消息来传递内容，实现双向通信，不共享信息（这一点可以通过第三方来实现，redis之类的，这时需要一个专门负责通知的进程，以将更新同步到多个工作进程）。")]),t._v(" "),_("p",[_("strong",[t._v("工作进程监听同一个端口")]),t._v("：主进程传递句柄文件描述符到IPC，然后工作进程读取它，解析之后创建对应的服务器对象。通过句柄解析还原出来的工作进程，它们的文件描述符是一样的，所以可以监听同一个端口。工作进程提供服务是"),_("strong",[t._v("抢占式")]),t._v("的。后来有一个叫做"),_("strong",[t._v("轮叫调度")]),t._v("的策略来维持工作进程的"),_("strong",[t._v("负载均衡")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"进程的健壮性和稳定性问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程的健壮性和稳定性问题"}},[t._v("#")]),t._v(" 进程的健壮性和稳定性问题")]),t._v(" "),_("p",[t._v("主进程通过一些事件来得知工作进程的状态（error, exit, close），比如可以通过exit事件知道某个工作进程退出了，然后可以重启一个进程来代替它。还有"),_("strong",[t._v("自杀信号")]),t._v("，"),_("strong",[t._v("限量重启")]),t._v("等策略来提高进程集群的健壮性和稳定性。")])])}),[],!1,null,null,null);e.default=s.exports}}]);