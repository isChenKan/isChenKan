# JS基础之：callback和promise
> 这里我不会过多的讨论它们具体的写法、API层面的东西，promise想必大家都会用，这里主要讨论的是API背后的原理。

## callback为什么不好
我们的大脑其实是单线程在工作的，当然，我是说除了呼吸，心跳这些维持生命迹象的行为外。我们感觉自己在多线程的做一些事情的时候，其实我们是在进行快速的上下文切换而已。快到有一种我们的大脑在同时处理多件事情一样。我们其实不能一心多用。举个例子：我们很难真正做到一遍打字一边打电话，当我们以为自己在同时做这两件事情的时候，其实是迅速的在这两件事情之间切换。我们的大脑其实是同步的，有点像是顺序执行任务的。所以通过回调写出来的异步代码，跟我们的大脑的处理逻辑是相悖的，这很不自然。
### 回调地狱
先看一段假设的代码：
```js
doA(() => {
  doB()
  doC(() => {
    doD()
  })
  doE()
})
doF()
```
这段代码的实际的执行顺序应该是：`AFBCED`，但是，如果函数A和C不是异步的呢？

**回调地狱的问题不是嵌套和缩进**，你也可以把它写成线性的。问题在于它的同步异步是无法控制的，回调函数表达异步的方式让我们很难追踪代码的逻辑。
### 回调函数信任问题
```js
// A
$ajax('/some/api', (res) => {
// C 
})
// B
```
上面的代码执行顺序应该是：`ABC`，我们使用了一个第三方的ajax库，这里就存在控制反转，把程序的控制权给了第三方，存在严重的信任问题。第三方如果不执行回调函数怎么办？多次执行回调函数怎么办？执行回调过早或过晚？（不能确定是现在还是将来调用你的回调）我们需要在我们的代码中加入很多容错代码来处理这样的事情，这很累。

我们需要一种更同步、更顺序的方式来表达异步的代码。这就是`promise`!

## promise：承诺未来值
promise就像餐厅取餐叫号一样，你的这个号就是给你的承诺，一个未来值，一段时间后，你可以拿这个号去换取你的食物。或者餐厅告诉你，卖完了，换不了，这就是promise，要么完成，要么拒绝。

由于Promise封装了依赖于时间的状态——等待底层值的完成或拒绝，所以Promise本身是与时间无关的。因此，Promise可以按照可预测的方式组成(组合，使用.then)，而不用关心时序或底层的结果。一旦Promise决议，它就永远保持在这个状态。

### promise如何解决callback的信任问题
callback把控制权交给第三方导致了信任问题，第三方代码可能过早或过晚的调用我们传给它的回调函数，而promise就不用担心这个问题，promise总是异步的。而且promise的回调调用次数是一次，不会出现多次调用回调函数的情况。

之前我们使用callback，我们把回调函数传给了`$ajax`，是不值得信任的。而**promise决议之后只负责通知（成功或拒绝），现在我们把回调传给promise的then来精确控制。**

### 异常捕获
另外，promise可以用catch来捕获异常，callback虽然可以用try catch来捕获异常，但是无法捕捉到异步的异常，所以相比来说，promise的机制更好。

记住：**promise只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次**。